{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Visualiza\u00e7\u00e3o de Dados e Aplica\u00e7\u00f5es Gr\u00e1ficas com Blender Apresenta\u00e7\u00e3o Unity 3D Unreal Blender","title":"Home"},{"location":"#visualizacao-de-dados-e-aplicacoes-graficas-com-blender","text":"","title":"Visualiza\u00e7\u00e3o de Dados e Aplica\u00e7\u00f5es Gr\u00e1ficas com Blender"},{"location":"#apresentacao","text":"","title":"Apresenta\u00e7\u00e3o"},{"location":"#unity-3d","text":"","title":"Unity 3D"},{"location":"#unreal","text":"","title":"Unreal"},{"location":"#blender","text":"","title":"Blender"},{"location":"Exemplos/","text":"Upbge Blender","title":"Index"},{"location":"Exemplos/Cena%20Upbge/","text":"Para enquadrar a c\u00e2mera automaticamente com base nos dados carregados do JSON, voc\u00ea pode ajustar a posi\u00e7\u00e3o e o \u00e2ngulo da c\u00e2mera dinamicamente no script Python. A ideia \u00e9 calcular a posi\u00e7\u00e3o m\u00e9dia dos objetos ou o ponto central da cena e ajustar a c\u00e2mera para enquadrar todos os objetos vis\u00edveis. 1. Modifica\u00e7\u00e3o do Script Python Vamos modificar o script para que, ap\u00f3s criar os objetos, a c\u00e2mera seja posicionada e orientada automaticamente para enquadrar todos eles. Script Python Modificado: import bpy import json # Caminho para o arquivo JSON filepath = \"/caminho/para/o/arquivo/data.json\" # Fun\u00e7\u00e3o para carregar dados JSON def load_json(filepath): with open(filepath, 'r') as file: return json.load(file) # Fun\u00e7\u00e3o para criar objetos a partir dos dados, ajustando altura def create_objects_from_data(data): objects = [] for item in data: # Criar o objeto cubo bpy.ops.mesh.primitive_cube_add(size=1, location=(item['x'], item['y'], item['z'])) obj = bpy.context.object # Definir nome do objeto obj.name = item['name'] # Ajustar altura do cubo (alongar no eixo Z) obj.scale.z = item['height'] # Adicionar o objeto \u00e0 lista objects.append(obj) return objects # Fun\u00e7\u00e3o para posicionar a c\u00e2mera automaticamente def position_camera(objects): # Calcular a posi\u00e7\u00e3o m\u00e9dia dos objetos x_coords = [obj.location.x for obj in objects] y_coords = [obj.location.y for obj in objects] z_coords = [obj.location.z + obj.scale.z/2 for obj in objects] # Considerando altura x_center = sum(x_coords) / len(x_coords) y_center = sum(y_coords) / len(y_coords) z_max = max(z_coords) # Ponto mais alto # Ajustar posi\u00e7\u00e3o da c\u00e2mera camera = bpy.data.objects['Camera'] camera.location.x = x_center camera.location.y = y_center - max(y_coords) * 2 # Dist\u00e2ncia suficiente para ver todos os objetos camera.location.z = z_max * 1.5 # Eleva a c\u00e2mera para ver todos os objetos # Apontar a c\u00e2mera para o centro dos objetos camera.rotation_euler = (1.1, 0, 0) # Ajuste manual da rota\u00e7\u00e3o (X, Y, Z) camera.data.lens = 35 # Opcional: ajustar o campo de vis\u00e3o da c\u00e2mera # Carregar dados e criar objetos data = load_json(filepath) objects = create_objects_from_data(data) # Posicionar a c\u00e2mera com base nos objetos position_camera(objects) 2. Explica\u00e7\u00e3o do Script: Carregar e Criar Objetos: O script cria os objetos e retorna uma lista dos objetos criados. Calcular o Centro: Calcula a posi\u00e7\u00e3o m\u00e9dia dos objetos ( x_center , y_center ) e o ponto mais alto ( z_max ). Posicionar a C\u00e2mera: Posiciona a c\u00e2mera no centro dos objetos e ajusta sua altura para garantir que todos os objetos sejam vis\u00edveis. Apontar a C\u00e2mera: A c\u00e2mera \u00e9 orientada para olhar para o centro da cena. 3. Executar o Script Abra o Editor de Texto: No UPBGE, abra o Editor de Texto e cole o script modificado. Executar o Script: Pressione \"Run Script\" para criar os objetos e posicionar a c\u00e2mera automaticamente. 4. Testar no Modo de Jogo Entrar no Modo de Jogo: Pressione P para entrar no modo de jogo e verifique se a c\u00e2mera est\u00e1 enquadrando todos os objetos corretamente. 5. Ajustes Finais Campo de Vis\u00e3o: Voc\u00ea pode ajustar o camera.data.lens para aumentar ou diminuir o campo de vis\u00e3o da c\u00e2mera. Rota\u00e7\u00e3o da C\u00e2mera: Se necess\u00e1rio, ajuste manualmente a rota\u00e7\u00e3o da c\u00e2mera para enquadrar melhor os objetos. Agora, sua cena 3D no UPBGE n\u00e3o s\u00f3 cria objetos baseados nos dados JSON, mas tamb\u00e9m posiciona a c\u00e2mera automaticamente para que todos os objetos sejam vis\u00edveis! Baseado no c\u00f3digo anterior altere os dados json para que todos os objetos fiquem no mesmo y e z Para modificar o JSON de modo que todos os objetos fiquem no mesmo y e z , voc\u00ea pode ajustar os valores desses eixos no arquivo JSON. Vou fornecer um exemplo de JSON atualizado onde todos os objetos t\u00eam a mesma coordenada y e z . 1. Exemplo de data.json com y e z fixos [ {\"name\": \"Item1\", \"x\": 1, \"y\": 0, \"z\": 0, \"height\": 2.5}, {\"name\": \"Item2\", \"x\": 4, \"y\": 0, \"z\": 0, \"height\": 1.8}, {\"name\": \"Item3\", \"x\": 7, \"y\": 0, \"z\": 0, \"height\": 3.0}, {\"name\": \"Item4\", \"x\": 10, \"y\": 0, \"z\": 0, \"height\": 2.0}, {\"name\": \"Item5\", \"x\": 13, \"y\": 0, \"z\": 0, \"height\": 1.5} ] 2. Explica\u00e7\u00e3o do JSON: x : As posi\u00e7\u00f5es x variam, o que significa que os objetos ser\u00e3o dispostos ao longo do eixo X. y : Todos os valores de y s\u00e3o 0 , ent\u00e3o todos os objetos estar\u00e3o alinhados ao longo do eixo Y. z : Todos os valores de z s\u00e3o 0 , ent\u00e3o todos os objetos ser\u00e3o colocados na mesma altura inicial. A altura real dos objetos ser\u00e1 determinada pelo valor height . 3. Usar o JSON Atualizado no Script Python Voc\u00ea pode usar o JSON atualizado com o script anterior sem nenhuma modifica\u00e7\u00e3o. O script criar\u00e1 os objetos no UPBGE, e todos estar\u00e3o alinhados ao longo do eixo X, com a mesma altura inicial em z = 0 e y = 0 . 4. Executar o Script Certifique-se de que o JSON atualizado esteja salvo com os valores acima. Execute o script Python como descrito anteriormente para criar os objetos e posicionar a c\u00e2mera. 5. Visualizar os Objetos No modo de jogo ( P ), voc\u00ea ver\u00e1 todos os objetos alinhados em uma linha ao longo do eixo X, com diferentes alturas, mas na mesma posi\u00e7\u00e3o y e z . Se precisar de mais ajustes ou tiver outras perguntas, estou \u00e0 disposi\u00e7\u00e3o para ajudar! Adicionar no script uma luz que simule o dia ensolarado Para adicionar uma luz que simule um dia ensolarado na cena, vamos utilizar uma luz do tipo Sun no UPBGE. A luz do tipo Sun emite luz paralela, semelhante \u00e0 luz solar, e \u00e9 ideal para iluminar toda a cena de forma uniforme. 1. Modifica\u00e7\u00e3o do Script Python Aqui est\u00e1 o script modificado para incluir a cria\u00e7\u00e3o de uma luz solar ( Sun ) junto com os objetos e o posicionamento da c\u00e2mera. Script Python Modificado com Luz Solar: import bpy import json # Caminho para o arquivo JSON filepath = \"/caminho/para/o/arquivo/data.json\" # Fun\u00e7\u00e3o para carregar dados JSON def load_json(filepath): with open(filepath, 'r') as file: return json.load(file) # Fun\u00e7\u00e3o para criar objetos a partir dos dados, ajustando altura def create_objects_from_data(data): objects = [] for item in data: # Criar o objeto cubo bpy.ops.mesh.primitive_cube_add(size=1, location=(item['x'], item['y'], item['z'])) obj = bpy.context.object # Definir nome do objeto obj.name = item['name'] # Ajustar altura do cubo (alongar no eixo Z) obj.scale.z = item['height'] # Adicionar o objeto \u00e0 lista objects.append(obj) return objects # Fun\u00e7\u00e3o para posicionar a c\u00e2mera automaticamente def position_camera(objects): # Calcular a posi\u00e7\u00e3o m\u00e9dia dos objetos x_coords = [obj.location.x for obj in objects] y_coords = [obj.location.y for obj in objects] z_coords = [obj.location.z + obj.scale.z/2 for obj in objects] # Considerando altura x_center = sum(x_coords) / len(x_coords) y_center = sum(y_coords) / len(y_coords) z_max = max(z_coords) # Ponto mais alto # Ajustar posi\u00e7\u00e3o da c\u00e2mera camera = bpy.data.objects['Camera'] camera.location.x = x_center camera.location.y = y_center - max(y_coords) * 2 # Dist\u00e2ncia suficiente para ver todos os objetos camera.location.z = z_max * 1.5 # Eleva a c\u00e2mera para ver todos os objetos # Apontar a c\u00e2mera para o centro dos objetos camera.rotation_euler = (1.1, 0, 0) # Ajuste manual da rota\u00e7\u00e3o (X, Y, Z) camera.data.lens = 35 # Opcional: ajustar o campo de vis\u00e3o da c\u00e2mera # Fun\u00e7\u00e3o para adicionar uma luz solar (Sun) def add_sun_light(): # Adicionar a luz do tipo Sun bpy.ops.object.light_add(type='SUN', radius=1, location=(10, -10, 10)) sun = bpy.context.object # Configurar a rota\u00e7\u00e3o da luz para simular um dia ensolarado sun.rotation_euler = (0.7854, 0, 0.7854) # Inclina a luz para simular o sol no c\u00e9u # Ajustar a intensidade e cor da luz sun.data.energy = 5 # Intensidade da luz solar sun.data.color = (1, 1, 0.98) # Levemente amarelada para simular o sol # Carregar dados e criar objetos data = load_json(filepath) objects = create_objects_from_data(data) # Posicionar a c\u00e2mera com base nos objetos position_camera(objects) # Adicionar uma luz solar \u00e0 cena add_sun_light() 2. Explica\u00e7\u00e3o das Modifica\u00e7\u00f5es: Adicionar Luz Solar ( Sun ): A fun\u00e7\u00e3o add_sun_light() adiciona uma luz do tipo Sun \u00e0 cena. Posicionamento da Luz: A luz \u00e9 posicionada no ponto (10, -10, 10) , o que simula o sol vindo de um \u00e2ngulo. Rota\u00e7\u00e3o da Luz: A rota\u00e7\u00e3o da luz \u00e9 ajustada para simular a ilumina\u00e7\u00e3o solar em um dia ensolarado. Configura\u00e7\u00e3o da Intensidade e Cor: A intensidade da luz \u00e9 aumentada para 5 , e a cor \u00e9 ajustada para um tom levemente amarelado, que \u00e9 t\u00edpico da luz solar. 3. Executar o Script Abra o Editor de Texto: No UPBGE, abra o Editor de Texto e cole o script modificado. Execute o Script: Pressione \"Run Script\" para criar os objetos, posicionar a c\u00e2mera e adicionar a luz solar. 4. Testar no Modo de Jogo Entrar no Modo de Jogo: Pressione P para entrar no modo de jogo e verifique como a luz solar ilumina a cena. 5. Ajustes Finais Intensidade da Luz: Se a cena estiver muito clara ou escura, ajuste sun.data.energy para aumentar ou diminuir a intensidade da luz solar. Rota\u00e7\u00e3o da Luz: Ajuste sun.rotation_euler se quiser alterar o \u00e2ngulo de incid\u00eancia da luz. Agora sua cena 3D no UPBGE simula um dia ensolarado, com luz solar natural iluminando todos os objetos! Adicionar um material met\u00e1lico aos objetos do cena anterior Para adicionar um material met\u00e1lico aos objetos na cena do UPBGE, voc\u00ea pode modificar o script para incluir a cria\u00e7\u00e3o e aplica\u00e7\u00e3o de um material com propriedades met\u00e1licas para cada objeto. Abaixo est\u00e1 o script atualizado que inclui essa funcionalidade. 1. Modifica\u00e7\u00e3o do Script Python Vamos adicionar uma fun\u00e7\u00e3o para criar um material met\u00e1lico e aplic\u00e1-lo aos objetos criados a partir dos dados JSON. Script Python Modificado com Material Met\u00e1lico: import bpy import json # Caminho para o arquivo JSON filepath = \"/caminho/para/o/arquivo/data.json\" # Fun\u00e7\u00e3o para carregar dados JSON def load_json(filepath): with open(filepath, 'r') as file: return json.load(file) # Fun\u00e7\u00e3o para criar e aplicar um material met\u00e1lico aos objetos def create_metallic_material(): # Criar um novo material material = bpy.data.materials.new(name=\"MetallicMaterial\") # Ativar o uso de nodes material.use_nodes = True # Obter o n\u00f3 de Principled BSDF (n\u00f3 padr\u00e3o) principled_bsdf = material.node_tree.nodes.get(\"Principled BSDF\") # Configurar as propriedades do material para ser met\u00e1lico principled_bsdf.inputs['Metallic'].default_value = 1.0 # Valor met\u00e1lico m\u00e1ximo principled_bsdf.inputs['Roughness'].default_value = 0.3 # Controle de rugosidade (menos rugoso = mais brilhante) principled_bsdf.inputs['Base Color'].default_value = (0.8, 0.8, 0.8, 1) # Cor base (cinza claro) return material # Fun\u00e7\u00e3o para criar objetos a partir dos dados, ajustando altura e aplicando material def create_objects_from_data(data, material): objects = [] for item in data: # Criar o objeto cubo bpy.ops.mesh.primitive_cube_add(size=1, location=(item['x'], item['y'], item['z'])) obj = bpy.context.object # Definir nome do objeto obj.name = item['name'] # Ajustar altura do cubo (alongar no eixo Z) obj.scale.z = item['height'] # Aplicar o material met\u00e1lico ao objeto if obj.data.materials: obj.data.materials[0] = material else: obj.data.materials.append(material) # Adicionar o objeto \u00e0 lista objects.append(obj) return objects # Fun\u00e7\u00e3o para posicionar a c\u00e2mera automaticamente def position_camera(objects): # Calcular a posi\u00e7\u00e3o m\u00e9dia dos objetos x_coords = [obj.location.x for obj in objects] y_coords = [obj.location.y for obj in objects] z_coords = [obj.location.z + obj.scale.z/2 for obj in objects] # Considerando altura x_center = sum(x_coords) / len(x_coords) y_center = sum(y_coords) / len(y_coords) z_max = max(z_coords) # Ponto mais alto # Ajustar posi\u00e7\u00e3o da c\u00e2mera camera = bpy.data.objects['Camera'] camera.location.x = x_center camera.location.y = y_center - max(y_coords) * 2 # Dist\u00e2ncia suficiente para ver todos os objetos camera.location.z = z_max * 1.5 # Eleva a c\u00e2mera para ver todos os objetos # Apontar a c\u00e2mera para o centro dos objetos camera.rotation_euler = (1.1, 0, 0) # Ajuste manual da rota\u00e7\u00e3o (X, Y, Z) camera.data.lens = 35 # Opcional: ajustar o campo de vis\u00e3o da c\u00e2mera # Fun\u00e7\u00e3o para adicionar uma luz solar (Sun) def add_sun_light(): # Adicionar a luz do tipo Sun bpy.ops.object.light_add(type='SUN', radius=1, location=(10, -10, 10)) sun = bpy.context.object # Configurar a rota\u00e7\u00e3o da luz para simular um dia ensolarado sun.rotation_euler = (0.7854, 0, 0.7854) # Inclina a luz para simular o sol no c\u00e9u # Ajustar a intensidade e cor da luz sun.data.energy = 5 # Intensidade da luz solar sun.data.color = (1, 1, 0.98) # Levemente amarelada para simular o sol # Carregar dados e criar material met\u00e1lico data = load_json(filepath) metallic_material = create_metallic_material() # Criar objetos e aplicar o material met\u00e1lico objects = create_objects_from_data(data, metallic_material) # Posicionar a c\u00e2mera com base nos objetos position_camera(objects) # Adicionar uma luz solar \u00e0 cena add_sun_light() 2. Explica\u00e7\u00e3o das Modifica\u00e7\u00f5es: Criar Material Met\u00e1lico: A fun\u00e7\u00e3o create_metallic_material() cria um novo material com propriedades met\u00e1licas, usando o shader Principled BSDF . Metallic: Configurado para 1.0, que define o material como completamente met\u00e1lico. Roughness: Configurado para 0.3, o que d\u00e1 ao material uma apar\u00eancia moderadamente brilhante. Base Color: Definido como um cinza claro, que \u00e9 t\u00edpico para metais como o a\u00e7o inoxid\u00e1vel. Aplicar Material: Durante a cria\u00e7\u00e3o dos objetos, o material met\u00e1lico \u00e9 aplicado a cada objeto. 3. Executar o Script Abra o Editor de Texto: No UPBGE, abra o Editor de Texto e cole o script modificado. Execute o Script: Pressione \"Run Script\" para criar os objetos, posicionar a c\u00e2mera, adicionar a luz solar e aplicar o material met\u00e1lico. 4. Testar no Modo de Jogo Entrar no Modo de Jogo: Pressione P para entrar no modo de jogo e visualizar os objetos com o material met\u00e1lico aplicado. 5. Ajustes Finais Cor do Material: Se desejar, voc\u00ea pode ajustar a Base Color do material met\u00e1lico para diferentes tons de metal, como cobre, ouro, etc. Roughness: Aumentar ou diminuir o valor de Roughness afetar\u00e1 o brilho e a nitidez dos reflexos. Agora, os objetos na sua cena 3D no UPBGE ter\u00e3o um material met\u00e1lico aplicado, com ilumina\u00e7\u00e3o simulando um dia ensolarado. Adicionar um terreno Para adicionar um terreno na sua cena 3D no UPBGE, voc\u00ea pode criar um plano grande que representar\u00e1 o ch\u00e3o da cena e aplicar um material a esse plano para dar a apar\u00eancia de terreno. Aqui est\u00e1 como voc\u00ea pode modificar o script para adicionar esse terreno. 1. Modifica\u00e7\u00e3o do Script Python Vamos adicionar uma fun\u00e7\u00e3o para criar o terreno e aplicar um material b\u00e1sico a ele. Script Python Modificado com Terreno: import bpy import json # Caminho para o arquivo JSON filepath = \"/caminho/para/o/arquivo/data.json\" # Fun\u00e7\u00e3o para carregar dados JSON def load_json(filepath): with open(filepath, 'r') as file: return json.load(file) # Fun\u00e7\u00e3o para criar e aplicar um material met\u00e1lico aos objetos def create_metallic_material(): material = bpy.data.materials.new(name=\"MetallicMaterial\") material.use_nodes = True principled_bsdf = material.node_tree.nodes.get(\"Principled BSDF\") principled_bsdf.inputs['Metallic'].default_value = 1.0 principled_bsdf.inputs['Roughness'].default_value = 0.3 principled_bsdf.inputs['Base Color'].default_value = (0.8, 0.8, 0.8, 1) return material # Fun\u00e7\u00e3o para criar objetos a partir dos dados, ajustando altura e aplicando material def create_objects_from_data(data, material): objects = [] for item in data: bpy.ops.mesh.primitive_cube_add(size=1, location=(item['x'], item['y'], item['z'])) obj = bpy.context.object obj.name = item['name'] obj.scale.z = item['height'] if obj.data.materials: obj.data.materials[0] = material else: obj.data.materials.append(material) objects.append(obj) return objects # Fun\u00e7\u00e3o para criar o terreno def create_terrain(): # Adicionar um plano que servir\u00e1 como terreno bpy.ops.mesh.primitive_plane_add(size=50, location=(0, 0, 0)) terrain = bpy.context.object # Criar um material para o terreno terrain_material = bpy.data.materials.new(name=\"TerrainMaterial\") terrain_material.use_nodes = True # Obter o n\u00f3 de Principled BSDF principled_bsdf = terrain_material.node_tree.nodes.get(\"Principled BSDF\") # Configurar a cor e a rugosidade do terreno principled_bsdf.inputs['Base Color'].default_value = (0.3, 0.2, 0.1, 1) # Marrom principled_bsdf.inputs['Roughness'].default_value = 0.8 # Mais rugoso # Aplicar o material ao plano if terrain.data.materials: terrain.data.materials[0] = terrain_material else: terrain.data.materials.append(terrain_material) return terrain # Fun\u00e7\u00e3o para posicionar a c\u00e2mera automaticamente def position_camera(objects): x_coords = [obj.location.x for obj in objects] y_coords = [obj.location.y for obj in objects] z_coords = [obj.location.z + obj.scale.z/2 for obj in objects] x_center = sum(x_coords) / len(x_coords) y_center = sum(y_coords) / len(y_coords) z_max = max(z_coords) camera = bpy.data.objects['Camera'] camera.location.x = x_center camera.location.y = y_center - max(y_coords) * 2 camera.location.z = z_max * 1.5 camera.rotation_euler = (1.1, 0, 0) camera.data.lens = 35 # Fun\u00e7\u00e3o para adicionar uma luz solar (Sun) def add_sun_light(): bpy.ops.object.light_add(type='SUN', radius=1, location=(10, -10, 10)) sun = bpy.context.object sun.rotation_euler = (0.7854, 0, 0.7854) sun.data.energy = 5 sun.data.color = (1, 1, 0.98) # Carregar dados e criar material met\u00e1lico data = load_json(filepath) metallic_material = create_metallic_material() # Criar o terreno terrain = create_terrain() # Criar objetos e aplicar o material met\u00e1lico objects = create_objects_from_data(data, metallic_material) # Posicionar a c\u00e2mera com base nos objetos position_camera(objects) # Adicionar uma luz solar \u00e0 cena add_sun_light() 2. Explica\u00e7\u00e3o das Modifica\u00e7\u00f5es: Fun\u00e7\u00e3o create_terrain : Esta fun\u00e7\u00e3o cria um plano grande (tamanho 50) que serve como terreno. Material do Terreno: Um material simples \u00e9 criado e aplicado ao plano, com uma cor marrom e rugosidade alta para simular terra. Adi\u00e7\u00e3o do Terreno na Cena: O terreno \u00e9 criado antes dos objetos para garantir que os objetos sejam posicionados sobre ele. 3. Executar o Script Abra o Editor de Texto: No UPBGE, abra o Editor de Texto e cole o script modificado. Execute o Script: Pressione \"Run Script\" para criar o terreno, os objetos, posicionar a c\u00e2mera e adicionar a luz solar. 4. Testar no Modo de Jogo Entrar no Modo de Jogo: Pressione P para entrar no modo de jogo e visualizar o terreno com os objetos sobre ele. 5. Ajustes Finais Textura do Terreno: Para um terreno mais realista, voc\u00ea pode adicionar uma textura de solo ao material do plano. Tamanho do Plano: O tamanho do plano pode ser ajustado conforme necess\u00e1rio para cobrir toda a cena. Agora, sua cena no UPBGE inclui um terreno b\u00e1sico que serve de base para os objetos. Adicionar um c\u00e9u Para adicionar um c\u00e9u \u00e0 sua cena no UPBGE, voc\u00ea pode utilizar uma t\u00e9cnica simples chamada \"Sky Dome\" ou \"Sky Sphere\". Essa t\u00e9cnica envolve a cria\u00e7\u00e3o de uma grande esfera ao redor da cena, onde voc\u00ea pode aplicar uma textura de c\u00e9u. Outra alternativa seria usar o recurso de \"World Settings\" do Blender para configurar um c\u00e9u. 1. Adicionando um C\u00e9u usando uma Esfera (Sky Dome) Primeiro, vamos adicionar uma esfera invertida como uma \"Sky Dome\" e aplicar uma textura de c\u00e9u. Script Python Modificado com Sky Dome: import bpy import json # Caminho para o arquivo JSON filepath = \"/caminho/para/o/arquivo/data.json\" # Fun\u00e7\u00e3o para carregar dados JSON def load_json(filepath): with open(filepath, 'r') as file: return json.load(file) # Fun\u00e7\u00e3o para criar e aplicar um material met\u00e1lico aos objetos def create_metallic_material(): material = bpy.data.materials.new(name=\"MetallicMaterial\") material.use_nodes = True principled_bsdf = material.node_tree.nodes.get(\"Principled BSDF\") principled_bsdf.inputs['Metallic'].default_value = 1.0 principled_bsdf.inputs['Roughness'].default_value = 0.3 principled_bsdf.inputs['Base Color'].default_value = (0.8, 0.8, 0.8, 1) return material # Fun\u00e7\u00e3o para criar objetos a partir dos dados, ajustando altura e aplicando material def create_objects_from_data(data, material): objects = [] for item in data: bpy.ops.mesh.primitive_cube_add(size=1, location=(item['x'], item['y'], item['z'])) obj = bpy.context.object obj.name = item['name'] obj.scale.z = item['height'] if obj.data.materials: obj.data.materials[0] = material else: obj.data.materials.append(material) objects.append(obj) return objects # Fun\u00e7\u00e3o para criar o terreno def create_terrain(): bpy.ops.mesh.primitive_plane_add(size=50, location=(0, 0, 0)) terrain = bpy.context.object terrain_material = bpy.data.materials.new(name=\"TerrainMaterial\") terrain_material.use_nodes = True principled_bsdf = terrain_material.node_tree.nodes.get(\"Principled BSDF\") principled_bsdf.inputs['Base Color'].default_value = (0.3, 0.2, 0.1, 1) # Marrom principled_bsdf.inputs['Roughness'].default_value = 0.8 # Mais rugoso if terrain.data.materials: terrain.data.materials[0] = terrain_material else: terrain.data.materials.append(terrain_material) return terrain # Fun\u00e7\u00e3o para criar o c\u00e9u (Sky Dome) def create_sky_dome(): # Criar uma esfera grande para representar o c\u00e9u bpy.ops.mesh.primitive_uv_sphere_add(radius=100, location=(0, 0, 0)) sky_dome = bpy.context.object # Inverter as normais para que a esfera seja vis\u00edvel de dentro (Sky Dome) bpy.ops.object.mode_set(mode='EDIT') bpy.ops.mesh.select_all(action='SELECT') bpy.ops.mesh.flip_normals() bpy.ops.object.mode_set(mode='OBJECT') # Criar um material para o c\u00e9u sky_material = bpy.data.materials.new(name=\"SkyMaterial\") sky_material.use_nodes = True # Adicionar uma textura ao material do c\u00e9u bsdf = sky_material.node_tree.nodes[\"Principled BSDF\"] tex_image = sky_material.node_tree.nodes.new('ShaderNodeTexImage') # Carregar uma imagem de textura de c\u00e9u (substitua pelo caminho da sua textura) tex_image.image = bpy.data.images.load(\"/caminho/para/sua/textura_de_ceu.jpg\") # Conectar a textura ao material sky_material.node_tree.links.new(bsdf.inputs['Base Color'], tex_image.outputs['Color']) # Aplicar o material \u00e0 esfera sky_dome.data.materials.append(sky_material) return sky_dome # Fun\u00e7\u00e3o para posicionar a c\u00e2mera automaticamente def position_camera(objects): x_coords = [obj.location.x for obj in objects] y_coords = [obj.location.y for obj in objects] z_coords = [obj.location.z + obj.scale.z/2 for obj in objects] x_center = sum(x_coords) / len(x_coords) y_center = sum(y_coords) / len(y_coords) z_max = max(z_coords) camera = bpy.data.objects['Camera'] camera.location.x = x_center camera.location.y = y_center - max(y_coords) * 2 camera.location.z = z_max * 1.5 camera.rotation_euler = (1.1, 0, 0) camera.data.lens = 35 # Fun\u00e7\u00e3o para adicionar uma luz solar (Sun) def add_sun_light(): bpy.ops.object.light_add(type='SUN', radius=1, location=(10, -10, 10)) sun = bpy.context.object sun.rotation_euler = (0.7854, 0, 0.7854) sun.data.energy = 5 sun.data.color = (1, 1, 0.98) # Carregar dados e criar material met\u00e1lico data = load_json(filepath) metallic_material = create_metallic_material() # Criar o terreno terrain = create_terrain() # Criar o c\u00e9u (Sky Dome) sky_dome = create_sky_dome() # Criar objetos e aplicar o material met\u00e1lico objects = create_objects_from_data(data, metallic_material) # Posicionar a c\u00e2mera com base nos objetos position_camera(objects) # Adicionar uma luz solar \u00e0 cena add_sun_light() 2. Explica\u00e7\u00e3o das Modifica\u00e7\u00f5es: Fun\u00e7\u00e3o create_sky_dome : Esta fun\u00e7\u00e3o cria uma esfera grande ( radius=100 ) que representa o c\u00e9u ao redor da cena. Invers\u00e3o das Normais: As normais da esfera s\u00e3o invertidas para que a superf\u00edcie interna seja vis\u00edvel, criando um efeito de \"Sky Dome\". Material do C\u00e9u: Um material \u00e9 criado e uma textura de c\u00e9u \u00e9 aplicada a ele. Textura de C\u00e9u: Substitua \"/caminho/para/sua/textura_de_ceu.jpg\" pelo caminho da sua textura de c\u00e9u. 3. Usar World Settings para Configurar o C\u00e9u (Alternativa) Se preferir usar o \"World Settings\" do Blender, aqui est\u00e1 como voc\u00ea pode configurar: Criar um Mundo: Em vez de adicionar um Sky Dome, voc\u00ea pode configurar o c\u00e9u diretamente no \"World Settings\". Adicionar um Background: No painel de \"World\", selecione Use Nodes e configure o Background para um tom de azul ou adicione uma textura de c\u00e9u. 4. Executar o Script Abra o Editor de Texto: No UPBGE, abra o Editor de Texto e cole o script modificado. Execute o Script: Pressione \"Run Script\" para criar o c\u00e9u, o terreno, os objetos, posicionar a c\u00e2mera e adicionar a luz solar. 5. Testar no Modo de Jogo Entrar no Modo de Jogo: Pressione P para entrar no modo de jogo e visualizar o c\u00e9u ao redor da sua cena. Agora, sua cena 3D no UPBGE inclui um c\u00e9u usando um \"Sky Dome\" ou configurando o \"World Settings\".","title":"Cena Upbge"},{"location":"Exemplos/Cena%20Upbge/#1-modificacao-do-script-python","text":"Vamos modificar o script para que, ap\u00f3s criar os objetos, a c\u00e2mera seja posicionada e orientada automaticamente para enquadrar todos eles.","title":"1. Modifica\u00e7\u00e3o do Script Python"},{"location":"Exemplos/Cena%20Upbge/#script-python-modificado","text":"import bpy import json # Caminho para o arquivo JSON filepath = \"/caminho/para/o/arquivo/data.json\" # Fun\u00e7\u00e3o para carregar dados JSON def load_json(filepath): with open(filepath, 'r') as file: return json.load(file) # Fun\u00e7\u00e3o para criar objetos a partir dos dados, ajustando altura def create_objects_from_data(data): objects = [] for item in data: # Criar o objeto cubo bpy.ops.mesh.primitive_cube_add(size=1, location=(item['x'], item['y'], item['z'])) obj = bpy.context.object # Definir nome do objeto obj.name = item['name'] # Ajustar altura do cubo (alongar no eixo Z) obj.scale.z = item['height'] # Adicionar o objeto \u00e0 lista objects.append(obj) return objects # Fun\u00e7\u00e3o para posicionar a c\u00e2mera automaticamente def position_camera(objects): # Calcular a posi\u00e7\u00e3o m\u00e9dia dos objetos x_coords = [obj.location.x for obj in objects] y_coords = [obj.location.y for obj in objects] z_coords = [obj.location.z + obj.scale.z/2 for obj in objects] # Considerando altura x_center = sum(x_coords) / len(x_coords) y_center = sum(y_coords) / len(y_coords) z_max = max(z_coords) # Ponto mais alto # Ajustar posi\u00e7\u00e3o da c\u00e2mera camera = bpy.data.objects['Camera'] camera.location.x = x_center camera.location.y = y_center - max(y_coords) * 2 # Dist\u00e2ncia suficiente para ver todos os objetos camera.location.z = z_max * 1.5 # Eleva a c\u00e2mera para ver todos os objetos # Apontar a c\u00e2mera para o centro dos objetos camera.rotation_euler = (1.1, 0, 0) # Ajuste manual da rota\u00e7\u00e3o (X, Y, Z) camera.data.lens = 35 # Opcional: ajustar o campo de vis\u00e3o da c\u00e2mera # Carregar dados e criar objetos data = load_json(filepath) objects = create_objects_from_data(data) # Posicionar a c\u00e2mera com base nos objetos position_camera(objects)","title":"Script Python Modificado:"},{"location":"Exemplos/Cena%20Upbge/#2-explicacao-do-script","text":"Carregar e Criar Objetos: O script cria os objetos e retorna uma lista dos objetos criados. Calcular o Centro: Calcula a posi\u00e7\u00e3o m\u00e9dia dos objetos ( x_center , y_center ) e o ponto mais alto ( z_max ). Posicionar a C\u00e2mera: Posiciona a c\u00e2mera no centro dos objetos e ajusta sua altura para garantir que todos os objetos sejam vis\u00edveis. Apontar a C\u00e2mera: A c\u00e2mera \u00e9 orientada para olhar para o centro da cena.","title":"2. Explica\u00e7\u00e3o do Script:"},{"location":"Exemplos/Cena%20Upbge/#3-executar-o-script","text":"Abra o Editor de Texto: No UPBGE, abra o Editor de Texto e cole o script modificado. Executar o Script: Pressione \"Run Script\" para criar os objetos e posicionar a c\u00e2mera automaticamente.","title":"3. Executar o Script"},{"location":"Exemplos/Cena%20Upbge/#4-testar-no-modo-de-jogo","text":"Entrar no Modo de Jogo: Pressione P para entrar no modo de jogo e verifique se a c\u00e2mera est\u00e1 enquadrando todos os objetos corretamente.","title":"4. Testar no Modo de Jogo"},{"location":"Exemplos/Cena%20Upbge/#5-ajustes-finais","text":"Campo de Vis\u00e3o: Voc\u00ea pode ajustar o camera.data.lens para aumentar ou diminuir o campo de vis\u00e3o da c\u00e2mera. Rota\u00e7\u00e3o da C\u00e2mera: Se necess\u00e1rio, ajuste manualmente a rota\u00e7\u00e3o da c\u00e2mera para enquadrar melhor os objetos. Agora, sua cena 3D no UPBGE n\u00e3o s\u00f3 cria objetos baseados nos dados JSON, mas tamb\u00e9m posiciona a c\u00e2mera automaticamente para que todos os objetos sejam vis\u00edveis!","title":"5. Ajustes Finais"},{"location":"Exemplos/Cena%20Upbge/#baseado-no-codigo-anterior-altere-os-dados-json-para-que-todos-os-objetos-fiquem-no-mesmo-y-e-z","text":"Para modificar o JSON de modo que todos os objetos fiquem no mesmo y e z , voc\u00ea pode ajustar os valores desses eixos no arquivo JSON. Vou fornecer um exemplo de JSON atualizado onde todos os objetos t\u00eam a mesma coordenada y e z .","title":"Baseado no c\u00f3digo anterior altere os dados json para que todos os objetos fiquem no mesmo y e z"},{"location":"Exemplos/Cena%20Upbge/#1-exemplo-de-datajson-com-y-e-z-fixos","text":"[ {\"name\": \"Item1\", \"x\": 1, \"y\": 0, \"z\": 0, \"height\": 2.5}, {\"name\": \"Item2\", \"x\": 4, \"y\": 0, \"z\": 0, \"height\": 1.8}, {\"name\": \"Item3\", \"x\": 7, \"y\": 0, \"z\": 0, \"height\": 3.0}, {\"name\": \"Item4\", \"x\": 10, \"y\": 0, \"z\": 0, \"height\": 2.0}, {\"name\": \"Item5\", \"x\": 13, \"y\": 0, \"z\": 0, \"height\": 1.5} ]","title":"1. Exemplo de data.json com y e z fixos"},{"location":"Exemplos/Cena%20Upbge/#2-explicacao-do-json","text":"x : As posi\u00e7\u00f5es x variam, o que significa que os objetos ser\u00e3o dispostos ao longo do eixo X. y : Todos os valores de y s\u00e3o 0 , ent\u00e3o todos os objetos estar\u00e3o alinhados ao longo do eixo Y. z : Todos os valores de z s\u00e3o 0 , ent\u00e3o todos os objetos ser\u00e3o colocados na mesma altura inicial. A altura real dos objetos ser\u00e1 determinada pelo valor height .","title":"2. Explica\u00e7\u00e3o do JSON:"},{"location":"Exemplos/Cena%20Upbge/#3-usar-o-json-atualizado-no-script-python","text":"Voc\u00ea pode usar o JSON atualizado com o script anterior sem nenhuma modifica\u00e7\u00e3o. O script criar\u00e1 os objetos no UPBGE, e todos estar\u00e3o alinhados ao longo do eixo X, com a mesma altura inicial em z = 0 e y = 0 .","title":"3. Usar o JSON Atualizado no Script Python"},{"location":"Exemplos/Cena%20Upbge/#4-executar-o-script","text":"Certifique-se de que o JSON atualizado esteja salvo com os valores acima. Execute o script Python como descrito anteriormente para criar os objetos e posicionar a c\u00e2mera.","title":"4. Executar o Script"},{"location":"Exemplos/Cena%20Upbge/#5-visualizar-os-objetos","text":"No modo de jogo ( P ), voc\u00ea ver\u00e1 todos os objetos alinhados em uma linha ao longo do eixo X, com diferentes alturas, mas na mesma posi\u00e7\u00e3o y e z . Se precisar de mais ajustes ou tiver outras perguntas, estou \u00e0 disposi\u00e7\u00e3o para ajudar!","title":"5. Visualizar os Objetos"},{"location":"Exemplos/Cena%20Upbge/#adicionar-no-script-uma-luz-que-simule-o-dia-ensolarado","text":"Para adicionar uma luz que simule um dia ensolarado na cena, vamos utilizar uma luz do tipo Sun no UPBGE. A luz do tipo Sun emite luz paralela, semelhante \u00e0 luz solar, e \u00e9 ideal para iluminar toda a cena de forma uniforme.","title":"Adicionar no script uma luz que simule o dia ensolarado"},{"location":"Exemplos/Cena%20Upbge/#1-modificacao-do-script-python_1","text":"Aqui est\u00e1 o script modificado para incluir a cria\u00e7\u00e3o de uma luz solar ( Sun ) junto com os objetos e o posicionamento da c\u00e2mera.","title":"1. Modifica\u00e7\u00e3o do Script Python"},{"location":"Exemplos/Cena%20Upbge/#script-python-modificado-com-luz-solar","text":"import bpy import json # Caminho para o arquivo JSON filepath = \"/caminho/para/o/arquivo/data.json\" # Fun\u00e7\u00e3o para carregar dados JSON def load_json(filepath): with open(filepath, 'r') as file: return json.load(file) # Fun\u00e7\u00e3o para criar objetos a partir dos dados, ajustando altura def create_objects_from_data(data): objects = [] for item in data: # Criar o objeto cubo bpy.ops.mesh.primitive_cube_add(size=1, location=(item['x'], item['y'], item['z'])) obj = bpy.context.object # Definir nome do objeto obj.name = item['name'] # Ajustar altura do cubo (alongar no eixo Z) obj.scale.z = item['height'] # Adicionar o objeto \u00e0 lista objects.append(obj) return objects # Fun\u00e7\u00e3o para posicionar a c\u00e2mera automaticamente def position_camera(objects): # Calcular a posi\u00e7\u00e3o m\u00e9dia dos objetos x_coords = [obj.location.x for obj in objects] y_coords = [obj.location.y for obj in objects] z_coords = [obj.location.z + obj.scale.z/2 for obj in objects] # Considerando altura x_center = sum(x_coords) / len(x_coords) y_center = sum(y_coords) / len(y_coords) z_max = max(z_coords) # Ponto mais alto # Ajustar posi\u00e7\u00e3o da c\u00e2mera camera = bpy.data.objects['Camera'] camera.location.x = x_center camera.location.y = y_center - max(y_coords) * 2 # Dist\u00e2ncia suficiente para ver todos os objetos camera.location.z = z_max * 1.5 # Eleva a c\u00e2mera para ver todos os objetos # Apontar a c\u00e2mera para o centro dos objetos camera.rotation_euler = (1.1, 0, 0) # Ajuste manual da rota\u00e7\u00e3o (X, Y, Z) camera.data.lens = 35 # Opcional: ajustar o campo de vis\u00e3o da c\u00e2mera # Fun\u00e7\u00e3o para adicionar uma luz solar (Sun) def add_sun_light(): # Adicionar a luz do tipo Sun bpy.ops.object.light_add(type='SUN', radius=1, location=(10, -10, 10)) sun = bpy.context.object # Configurar a rota\u00e7\u00e3o da luz para simular um dia ensolarado sun.rotation_euler = (0.7854, 0, 0.7854) # Inclina a luz para simular o sol no c\u00e9u # Ajustar a intensidade e cor da luz sun.data.energy = 5 # Intensidade da luz solar sun.data.color = (1, 1, 0.98) # Levemente amarelada para simular o sol # Carregar dados e criar objetos data = load_json(filepath) objects = create_objects_from_data(data) # Posicionar a c\u00e2mera com base nos objetos position_camera(objects) # Adicionar uma luz solar \u00e0 cena add_sun_light()","title":"Script Python Modificado com Luz Solar:"},{"location":"Exemplos/Cena%20Upbge/#2-explicacao-das-modificacoes","text":"Adicionar Luz Solar ( Sun ): A fun\u00e7\u00e3o add_sun_light() adiciona uma luz do tipo Sun \u00e0 cena. Posicionamento da Luz: A luz \u00e9 posicionada no ponto (10, -10, 10) , o que simula o sol vindo de um \u00e2ngulo. Rota\u00e7\u00e3o da Luz: A rota\u00e7\u00e3o da luz \u00e9 ajustada para simular a ilumina\u00e7\u00e3o solar em um dia ensolarado. Configura\u00e7\u00e3o da Intensidade e Cor: A intensidade da luz \u00e9 aumentada para 5 , e a cor \u00e9 ajustada para um tom levemente amarelado, que \u00e9 t\u00edpico da luz solar.","title":"2. Explica\u00e7\u00e3o das Modifica\u00e7\u00f5es:"},{"location":"Exemplos/Cena%20Upbge/#3-executar-o-script_1","text":"Abra o Editor de Texto: No UPBGE, abra o Editor de Texto e cole o script modificado. Execute o Script: Pressione \"Run Script\" para criar os objetos, posicionar a c\u00e2mera e adicionar a luz solar.","title":"3. Executar o Script"},{"location":"Exemplos/Cena%20Upbge/#4-testar-no-modo-de-jogo_1","text":"Entrar no Modo de Jogo: Pressione P para entrar no modo de jogo e verifique como a luz solar ilumina a cena.","title":"4. Testar no Modo de Jogo"},{"location":"Exemplos/Cena%20Upbge/#5-ajustes-finais_1","text":"Intensidade da Luz: Se a cena estiver muito clara ou escura, ajuste sun.data.energy para aumentar ou diminuir a intensidade da luz solar. Rota\u00e7\u00e3o da Luz: Ajuste sun.rotation_euler se quiser alterar o \u00e2ngulo de incid\u00eancia da luz. Agora sua cena 3D no UPBGE simula um dia ensolarado, com luz solar natural iluminando todos os objetos!","title":"5. Ajustes Finais"},{"location":"Exemplos/Cena%20Upbge/#adicionar-um-material-metalico-aos-objetos-do-cena-anterior","text":"Para adicionar um material met\u00e1lico aos objetos na cena do UPBGE, voc\u00ea pode modificar o script para incluir a cria\u00e7\u00e3o e aplica\u00e7\u00e3o de um material com propriedades met\u00e1licas para cada objeto. Abaixo est\u00e1 o script atualizado que inclui essa funcionalidade.","title":"Adicionar um material met\u00e1lico aos objetos do cena anterior"},{"location":"Exemplos/Cena%20Upbge/#1-modificacao-do-script-python_2","text":"Vamos adicionar uma fun\u00e7\u00e3o para criar um material met\u00e1lico e aplic\u00e1-lo aos objetos criados a partir dos dados JSON.","title":"1. Modifica\u00e7\u00e3o do Script Python"},{"location":"Exemplos/Cena%20Upbge/#script-python-modificado-com-material-metalico","text":"import bpy import json # Caminho para o arquivo JSON filepath = \"/caminho/para/o/arquivo/data.json\" # Fun\u00e7\u00e3o para carregar dados JSON def load_json(filepath): with open(filepath, 'r') as file: return json.load(file) # Fun\u00e7\u00e3o para criar e aplicar um material met\u00e1lico aos objetos def create_metallic_material(): # Criar um novo material material = bpy.data.materials.new(name=\"MetallicMaterial\") # Ativar o uso de nodes material.use_nodes = True # Obter o n\u00f3 de Principled BSDF (n\u00f3 padr\u00e3o) principled_bsdf = material.node_tree.nodes.get(\"Principled BSDF\") # Configurar as propriedades do material para ser met\u00e1lico principled_bsdf.inputs['Metallic'].default_value = 1.0 # Valor met\u00e1lico m\u00e1ximo principled_bsdf.inputs['Roughness'].default_value = 0.3 # Controle de rugosidade (menos rugoso = mais brilhante) principled_bsdf.inputs['Base Color'].default_value = (0.8, 0.8, 0.8, 1) # Cor base (cinza claro) return material # Fun\u00e7\u00e3o para criar objetos a partir dos dados, ajustando altura e aplicando material def create_objects_from_data(data, material): objects = [] for item in data: # Criar o objeto cubo bpy.ops.mesh.primitive_cube_add(size=1, location=(item['x'], item['y'], item['z'])) obj = bpy.context.object # Definir nome do objeto obj.name = item['name'] # Ajustar altura do cubo (alongar no eixo Z) obj.scale.z = item['height'] # Aplicar o material met\u00e1lico ao objeto if obj.data.materials: obj.data.materials[0] = material else: obj.data.materials.append(material) # Adicionar o objeto \u00e0 lista objects.append(obj) return objects # Fun\u00e7\u00e3o para posicionar a c\u00e2mera automaticamente def position_camera(objects): # Calcular a posi\u00e7\u00e3o m\u00e9dia dos objetos x_coords = [obj.location.x for obj in objects] y_coords = [obj.location.y for obj in objects] z_coords = [obj.location.z + obj.scale.z/2 for obj in objects] # Considerando altura x_center = sum(x_coords) / len(x_coords) y_center = sum(y_coords) / len(y_coords) z_max = max(z_coords) # Ponto mais alto # Ajustar posi\u00e7\u00e3o da c\u00e2mera camera = bpy.data.objects['Camera'] camera.location.x = x_center camera.location.y = y_center - max(y_coords) * 2 # Dist\u00e2ncia suficiente para ver todos os objetos camera.location.z = z_max * 1.5 # Eleva a c\u00e2mera para ver todos os objetos # Apontar a c\u00e2mera para o centro dos objetos camera.rotation_euler = (1.1, 0, 0) # Ajuste manual da rota\u00e7\u00e3o (X, Y, Z) camera.data.lens = 35 # Opcional: ajustar o campo de vis\u00e3o da c\u00e2mera # Fun\u00e7\u00e3o para adicionar uma luz solar (Sun) def add_sun_light(): # Adicionar a luz do tipo Sun bpy.ops.object.light_add(type='SUN', radius=1, location=(10, -10, 10)) sun = bpy.context.object # Configurar a rota\u00e7\u00e3o da luz para simular um dia ensolarado sun.rotation_euler = (0.7854, 0, 0.7854) # Inclina a luz para simular o sol no c\u00e9u # Ajustar a intensidade e cor da luz sun.data.energy = 5 # Intensidade da luz solar sun.data.color = (1, 1, 0.98) # Levemente amarelada para simular o sol # Carregar dados e criar material met\u00e1lico data = load_json(filepath) metallic_material = create_metallic_material() # Criar objetos e aplicar o material met\u00e1lico objects = create_objects_from_data(data, metallic_material) # Posicionar a c\u00e2mera com base nos objetos position_camera(objects) # Adicionar uma luz solar \u00e0 cena add_sun_light()","title":"Script Python Modificado com Material Met\u00e1lico:"},{"location":"Exemplos/Cena%20Upbge/#2-explicacao-das-modificacoes_1","text":"Criar Material Met\u00e1lico: A fun\u00e7\u00e3o create_metallic_material() cria um novo material com propriedades met\u00e1licas, usando o shader Principled BSDF . Metallic: Configurado para 1.0, que define o material como completamente met\u00e1lico. Roughness: Configurado para 0.3, o que d\u00e1 ao material uma apar\u00eancia moderadamente brilhante. Base Color: Definido como um cinza claro, que \u00e9 t\u00edpico para metais como o a\u00e7o inoxid\u00e1vel. Aplicar Material: Durante a cria\u00e7\u00e3o dos objetos, o material met\u00e1lico \u00e9 aplicado a cada objeto.","title":"2. Explica\u00e7\u00e3o das Modifica\u00e7\u00f5es:"},{"location":"Exemplos/Cena%20Upbge/#3-executar-o-script_2","text":"Abra o Editor de Texto: No UPBGE, abra o Editor de Texto e cole o script modificado. Execute o Script: Pressione \"Run Script\" para criar os objetos, posicionar a c\u00e2mera, adicionar a luz solar e aplicar o material met\u00e1lico.","title":"3. Executar o Script"},{"location":"Exemplos/Cena%20Upbge/#4-testar-no-modo-de-jogo_2","text":"Entrar no Modo de Jogo: Pressione P para entrar no modo de jogo e visualizar os objetos com o material met\u00e1lico aplicado.","title":"4. Testar no Modo de Jogo"},{"location":"Exemplos/Cena%20Upbge/#5-ajustes-finais_2","text":"Cor do Material: Se desejar, voc\u00ea pode ajustar a Base Color do material met\u00e1lico para diferentes tons de metal, como cobre, ouro, etc. Roughness: Aumentar ou diminuir o valor de Roughness afetar\u00e1 o brilho e a nitidez dos reflexos. Agora, os objetos na sua cena 3D no UPBGE ter\u00e3o um material met\u00e1lico aplicado, com ilumina\u00e7\u00e3o simulando um dia ensolarado.","title":"5. Ajustes Finais"},{"location":"Exemplos/Cena%20Upbge/#adicionar-um-terreno","text":"Para adicionar um terreno na sua cena 3D no UPBGE, voc\u00ea pode criar um plano grande que representar\u00e1 o ch\u00e3o da cena e aplicar um material a esse plano para dar a apar\u00eancia de terreno. Aqui est\u00e1 como voc\u00ea pode modificar o script para adicionar esse terreno.","title":"Adicionar um terreno"},{"location":"Exemplos/Cena%20Upbge/#1-modificacao-do-script-python_3","text":"Vamos adicionar uma fun\u00e7\u00e3o para criar o terreno e aplicar um material b\u00e1sico a ele.","title":"1. Modifica\u00e7\u00e3o do Script Python"},{"location":"Exemplos/Cena%20Upbge/#script-python-modificado-com-terreno","text":"import bpy import json # Caminho para o arquivo JSON filepath = \"/caminho/para/o/arquivo/data.json\" # Fun\u00e7\u00e3o para carregar dados JSON def load_json(filepath): with open(filepath, 'r') as file: return json.load(file) # Fun\u00e7\u00e3o para criar e aplicar um material met\u00e1lico aos objetos def create_metallic_material(): material = bpy.data.materials.new(name=\"MetallicMaterial\") material.use_nodes = True principled_bsdf = material.node_tree.nodes.get(\"Principled BSDF\") principled_bsdf.inputs['Metallic'].default_value = 1.0 principled_bsdf.inputs['Roughness'].default_value = 0.3 principled_bsdf.inputs['Base Color'].default_value = (0.8, 0.8, 0.8, 1) return material # Fun\u00e7\u00e3o para criar objetos a partir dos dados, ajustando altura e aplicando material def create_objects_from_data(data, material): objects = [] for item in data: bpy.ops.mesh.primitive_cube_add(size=1, location=(item['x'], item['y'], item['z'])) obj = bpy.context.object obj.name = item['name'] obj.scale.z = item['height'] if obj.data.materials: obj.data.materials[0] = material else: obj.data.materials.append(material) objects.append(obj) return objects # Fun\u00e7\u00e3o para criar o terreno def create_terrain(): # Adicionar um plano que servir\u00e1 como terreno bpy.ops.mesh.primitive_plane_add(size=50, location=(0, 0, 0)) terrain = bpy.context.object # Criar um material para o terreno terrain_material = bpy.data.materials.new(name=\"TerrainMaterial\") terrain_material.use_nodes = True # Obter o n\u00f3 de Principled BSDF principled_bsdf = terrain_material.node_tree.nodes.get(\"Principled BSDF\") # Configurar a cor e a rugosidade do terreno principled_bsdf.inputs['Base Color'].default_value = (0.3, 0.2, 0.1, 1) # Marrom principled_bsdf.inputs['Roughness'].default_value = 0.8 # Mais rugoso # Aplicar o material ao plano if terrain.data.materials: terrain.data.materials[0] = terrain_material else: terrain.data.materials.append(terrain_material) return terrain # Fun\u00e7\u00e3o para posicionar a c\u00e2mera automaticamente def position_camera(objects): x_coords = [obj.location.x for obj in objects] y_coords = [obj.location.y for obj in objects] z_coords = [obj.location.z + obj.scale.z/2 for obj in objects] x_center = sum(x_coords) / len(x_coords) y_center = sum(y_coords) / len(y_coords) z_max = max(z_coords) camera = bpy.data.objects['Camera'] camera.location.x = x_center camera.location.y = y_center - max(y_coords) * 2 camera.location.z = z_max * 1.5 camera.rotation_euler = (1.1, 0, 0) camera.data.lens = 35 # Fun\u00e7\u00e3o para adicionar uma luz solar (Sun) def add_sun_light(): bpy.ops.object.light_add(type='SUN', radius=1, location=(10, -10, 10)) sun = bpy.context.object sun.rotation_euler = (0.7854, 0, 0.7854) sun.data.energy = 5 sun.data.color = (1, 1, 0.98) # Carregar dados e criar material met\u00e1lico data = load_json(filepath) metallic_material = create_metallic_material() # Criar o terreno terrain = create_terrain() # Criar objetos e aplicar o material met\u00e1lico objects = create_objects_from_data(data, metallic_material) # Posicionar a c\u00e2mera com base nos objetos position_camera(objects) # Adicionar uma luz solar \u00e0 cena add_sun_light()","title":"Script Python Modificado com Terreno:"},{"location":"Exemplos/Cena%20Upbge/#2-explicacao-das-modificacoes_2","text":"Fun\u00e7\u00e3o create_terrain : Esta fun\u00e7\u00e3o cria um plano grande (tamanho 50) que serve como terreno. Material do Terreno: Um material simples \u00e9 criado e aplicado ao plano, com uma cor marrom e rugosidade alta para simular terra. Adi\u00e7\u00e3o do Terreno na Cena: O terreno \u00e9 criado antes dos objetos para garantir que os objetos sejam posicionados sobre ele.","title":"2. Explica\u00e7\u00e3o das Modifica\u00e7\u00f5es:"},{"location":"Exemplos/Cena%20Upbge/#3-executar-o-script_3","text":"Abra o Editor de Texto: No UPBGE, abra o Editor de Texto e cole o script modificado. Execute o Script: Pressione \"Run Script\" para criar o terreno, os objetos, posicionar a c\u00e2mera e adicionar a luz solar.","title":"3. Executar o Script"},{"location":"Exemplos/Cena%20Upbge/#4-testar-no-modo-de-jogo_3","text":"Entrar no Modo de Jogo: Pressione P para entrar no modo de jogo e visualizar o terreno com os objetos sobre ele.","title":"4. Testar no Modo de Jogo"},{"location":"Exemplos/Cena%20Upbge/#5-ajustes-finais_3","text":"Textura do Terreno: Para um terreno mais realista, voc\u00ea pode adicionar uma textura de solo ao material do plano. Tamanho do Plano: O tamanho do plano pode ser ajustado conforme necess\u00e1rio para cobrir toda a cena. Agora, sua cena no UPBGE inclui um terreno b\u00e1sico que serve de base para os objetos.","title":"5. Ajustes Finais"},{"location":"Exemplos/Cena%20Upbge/#adicionar-um-ceu","text":"Para adicionar um c\u00e9u \u00e0 sua cena no UPBGE, voc\u00ea pode utilizar uma t\u00e9cnica simples chamada \"Sky Dome\" ou \"Sky Sphere\". Essa t\u00e9cnica envolve a cria\u00e7\u00e3o de uma grande esfera ao redor da cena, onde voc\u00ea pode aplicar uma textura de c\u00e9u. Outra alternativa seria usar o recurso de \"World Settings\" do Blender para configurar um c\u00e9u.","title":"Adicionar um c\u00e9u"},{"location":"Exemplos/Cena%20Upbge/#1-adicionando-um-ceu-usando-uma-esfera-sky-dome","text":"Primeiro, vamos adicionar uma esfera invertida como uma \"Sky Dome\" e aplicar uma textura de c\u00e9u.","title":"1. Adicionando um C\u00e9u usando uma Esfera (Sky Dome)"},{"location":"Exemplos/Cena%20Upbge/#script-python-modificado-com-sky-dome","text":"import bpy import json # Caminho para o arquivo JSON filepath = \"/caminho/para/o/arquivo/data.json\" # Fun\u00e7\u00e3o para carregar dados JSON def load_json(filepath): with open(filepath, 'r') as file: return json.load(file) # Fun\u00e7\u00e3o para criar e aplicar um material met\u00e1lico aos objetos def create_metallic_material(): material = bpy.data.materials.new(name=\"MetallicMaterial\") material.use_nodes = True principled_bsdf = material.node_tree.nodes.get(\"Principled BSDF\") principled_bsdf.inputs['Metallic'].default_value = 1.0 principled_bsdf.inputs['Roughness'].default_value = 0.3 principled_bsdf.inputs['Base Color'].default_value = (0.8, 0.8, 0.8, 1) return material # Fun\u00e7\u00e3o para criar objetos a partir dos dados, ajustando altura e aplicando material def create_objects_from_data(data, material): objects = [] for item in data: bpy.ops.mesh.primitive_cube_add(size=1, location=(item['x'], item['y'], item['z'])) obj = bpy.context.object obj.name = item['name'] obj.scale.z = item['height'] if obj.data.materials: obj.data.materials[0] = material else: obj.data.materials.append(material) objects.append(obj) return objects # Fun\u00e7\u00e3o para criar o terreno def create_terrain(): bpy.ops.mesh.primitive_plane_add(size=50, location=(0, 0, 0)) terrain = bpy.context.object terrain_material = bpy.data.materials.new(name=\"TerrainMaterial\") terrain_material.use_nodes = True principled_bsdf = terrain_material.node_tree.nodes.get(\"Principled BSDF\") principled_bsdf.inputs['Base Color'].default_value = (0.3, 0.2, 0.1, 1) # Marrom principled_bsdf.inputs['Roughness'].default_value = 0.8 # Mais rugoso if terrain.data.materials: terrain.data.materials[0] = terrain_material else: terrain.data.materials.append(terrain_material) return terrain # Fun\u00e7\u00e3o para criar o c\u00e9u (Sky Dome) def create_sky_dome(): # Criar uma esfera grande para representar o c\u00e9u bpy.ops.mesh.primitive_uv_sphere_add(radius=100, location=(0, 0, 0)) sky_dome = bpy.context.object # Inverter as normais para que a esfera seja vis\u00edvel de dentro (Sky Dome) bpy.ops.object.mode_set(mode='EDIT') bpy.ops.mesh.select_all(action='SELECT') bpy.ops.mesh.flip_normals() bpy.ops.object.mode_set(mode='OBJECT') # Criar um material para o c\u00e9u sky_material = bpy.data.materials.new(name=\"SkyMaterial\") sky_material.use_nodes = True # Adicionar uma textura ao material do c\u00e9u bsdf = sky_material.node_tree.nodes[\"Principled BSDF\"] tex_image = sky_material.node_tree.nodes.new('ShaderNodeTexImage') # Carregar uma imagem de textura de c\u00e9u (substitua pelo caminho da sua textura) tex_image.image = bpy.data.images.load(\"/caminho/para/sua/textura_de_ceu.jpg\") # Conectar a textura ao material sky_material.node_tree.links.new(bsdf.inputs['Base Color'], tex_image.outputs['Color']) # Aplicar o material \u00e0 esfera sky_dome.data.materials.append(sky_material) return sky_dome # Fun\u00e7\u00e3o para posicionar a c\u00e2mera automaticamente def position_camera(objects): x_coords = [obj.location.x for obj in objects] y_coords = [obj.location.y for obj in objects] z_coords = [obj.location.z + obj.scale.z/2 for obj in objects] x_center = sum(x_coords) / len(x_coords) y_center = sum(y_coords) / len(y_coords) z_max = max(z_coords) camera = bpy.data.objects['Camera'] camera.location.x = x_center camera.location.y = y_center - max(y_coords) * 2 camera.location.z = z_max * 1.5 camera.rotation_euler = (1.1, 0, 0) camera.data.lens = 35 # Fun\u00e7\u00e3o para adicionar uma luz solar (Sun) def add_sun_light(): bpy.ops.object.light_add(type='SUN', radius=1, location=(10, -10, 10)) sun = bpy.context.object sun.rotation_euler = (0.7854, 0, 0.7854) sun.data.energy = 5 sun.data.color = (1, 1, 0.98) # Carregar dados e criar material met\u00e1lico data = load_json(filepath) metallic_material = create_metallic_material() # Criar o terreno terrain = create_terrain() # Criar o c\u00e9u (Sky Dome) sky_dome = create_sky_dome() # Criar objetos e aplicar o material met\u00e1lico objects = create_objects_from_data(data, metallic_material) # Posicionar a c\u00e2mera com base nos objetos position_camera(objects) # Adicionar uma luz solar \u00e0 cena add_sun_light()","title":"Script Python Modificado com Sky Dome:"},{"location":"Exemplos/Cena%20Upbge/#2-explicacao-das-modificacoes_3","text":"Fun\u00e7\u00e3o create_sky_dome : Esta fun\u00e7\u00e3o cria uma esfera grande ( radius=100 ) que representa o c\u00e9u ao redor da cena. Invers\u00e3o das Normais: As normais da esfera s\u00e3o invertidas para que a superf\u00edcie interna seja vis\u00edvel, criando um efeito de \"Sky Dome\". Material do C\u00e9u: Um material \u00e9 criado e uma textura de c\u00e9u \u00e9 aplicada a ele. Textura de C\u00e9u: Substitua \"/caminho/para/sua/textura_de_ceu.jpg\" pelo caminho da sua textura de c\u00e9u.","title":"2. Explica\u00e7\u00e3o das Modifica\u00e7\u00f5es:"},{"location":"Exemplos/Cena%20Upbge/#3-usar-world-settings-para-configurar-o-ceu-alternativa","text":"Se preferir usar o \"World Settings\" do Blender, aqui est\u00e1 como voc\u00ea pode configurar: Criar um Mundo: Em vez de adicionar um Sky Dome, voc\u00ea pode configurar o c\u00e9u diretamente no \"World Settings\". Adicionar um Background: No painel de \"World\", selecione Use Nodes e configure o Background para um tom de azul ou adicione uma textura de c\u00e9u.","title":"3. Usar World Settings para Configurar o C\u00e9u (Alternativa)"},{"location":"Exemplos/Cena%20Upbge/#4-executar-o-script_1","text":"Abra o Editor de Texto: No UPBGE, abra o Editor de Texto e cole o script modificado. Execute o Script: Pressione \"Run Script\" para criar o c\u00e9u, o terreno, os objetos, posicionar a c\u00e2mera e adicionar a luz solar.","title":"4. Executar o Script"},{"location":"Exemplos/Cena%20Upbge/#5-testar-no-modo-de-jogo","text":"Entrar no Modo de Jogo: Pressione P para entrar no modo de jogo e visualizar o c\u00e9u ao redor da sua cena. Agora, sua cena 3D no UPBGE inclui um c\u00e9u usando um \"Sky Dome\" ou configurando o \"World Settings\".","title":"5. Testar no Modo de Jogo"},{"location":"Exemplos/tecido/","text":"Tecido Para criar uma cena no Blender onde um tecido (um plano) cai sobre um cubo usando simula\u00e7\u00e3o de f\u00edsica de pano (cloth), siga estes passos: Passo 1: Configura\u00e7\u00e3o da Cena B\u00e1sica Abra o Blender . Remova os objetos padr\u00e3o (geralmente um cubo). Selecione o cubo, pressione X e clique em \"Delete\". Adicione um novo cubo : Pressione Shift + A para abrir o menu de adi\u00e7\u00e3o. Selecione Mesh > Cube . Posicione o cubo em Z = 0 para ficar na superf\u00edcie da grade. Adicione um plano (Plane) para ser o tecido : Pressione Shift + A novamente e selecione Mesh > Plane . Posicione o plano acima do cubo (em Z = 2 por exemplo). Passo 2: Configura\u00e7\u00e3o da F\u00edsica do Cubo Selecione o cubo . No painel de propriedades, v\u00e1 para a aba de Physics (\u00edcone de c\u00edrculo com pontos dentro) e clique em Collision . Isso faz com que o cubo interaja com o tecido. Passo 3: Configura\u00e7\u00e3o da F\u00edsica do Tecido Selecione o plano (que ser\u00e1 o tecido). No painel de propriedades, v\u00e1 para a aba de Physics e clique em Cloth . Aqui voc\u00ea pode ajustar as propriedades como massa, esticamento, flex\u00e3o, etc., para definir o comportamento do tecido. Passo 4: Ajuste da Resolu\u00e7\u00e3o do Plano (Opcional) Subdivida o plano para que o tecido tenha mais pontos para a simula\u00e7\u00e3o: Selecione o plano. Pressione Tab para entrar no Modo de Edi\u00e7\u00e3o. Pressione Right Click e selecione Subdivide . No painel inferior esquerdo, aumente o n\u00famero de cortes para dar mais detalhe ao tecido. Pressione Tab novamente para sair do Modo de Edi\u00e7\u00e3o. Passo 5: Simula\u00e7\u00e3o Inicie a simula\u00e7\u00e3o : Pressione Space ou Shift + Space para iniciar a anima\u00e7\u00e3o. O plano (tecido) deve cair sobre o cubo e reagir como um tecido real. Passo 6: Ajustes Finais Ajuste o comportamento da simula\u00e7\u00e3o na aba Cloth se necess\u00e1rio. Adicione uma superf\u00edcie de ch\u00e3o (novo plano abaixo do cubo) e marque como Collision para que o tecido n\u00e3o caia indefinidamente. Passo 7: Renderiza\u00e7\u00e3o Configure a ilumina\u00e7\u00e3o e a c\u00e2mera para a cena. Renderize a anima\u00e7\u00e3o ou um frame espec\u00edfico da queda do tecido. Essa configura\u00e7\u00e3o simples deve permitir que o tecido caia e se deforme ao colidir com o cubo, criando uma cena realista de simula\u00e7\u00e3o f\u00edsica no Blender. Para criar essa cena no Blender usando um script Python, voc\u00ea pode seguir o roteiro abaixo. Esse script cria um cubo, adiciona um plano como tecido, configura a simula\u00e7\u00e3o de f\u00edsica e executa a anima\u00e7\u00e3o. import bpy # Limpa a cena padr\u00e3o bpy.ops.object.select_all(action='SELECT') bpy.ops.object.delete(use_global=False) # Adiciona um cubo bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1)) # Pega o objeto rec\u00e9m-criado (o cubo) cube = bpy.context.object # Adiciona a f\u00edsica de colis\u00e3o ao cubo bpy.ops.object.modifier_add(type='COLLISION') # Adiciona um plano (plane) para ser o tecido bpy.ops.mesh.primitive_plane_add(size=4, location=(0, 0, 4)) plane = bpy.context.object # Subdivide o plano para aumentar a resolu\u00e7\u00e3o bpy.ops.object.mode_set(mode='EDIT') bpy.ops.mesh.subdivide(number_cuts=10) bpy.ops.object.mode_set(mode='OBJECT') # Adiciona a f\u00edsica de cloth ao plano bpy.ops.object.modifier_add(type='CLOTH') # Configura\u00e7\u00f5es adicionais para a simula\u00e7\u00e3o de tecido cloth_mod = plane.modifiers[\"Cloth\"] cloth_mod.settings.quality = 5 # Qualidade da simula\u00e7\u00e3o cloth_mod.settings.mass = 0.3 # Massa do tecido # Adiciona um ch\u00e3o abaixo do cubo para evitar queda infinita do tecido bpy.ops.mesh.primitive_plane_add(size=10, location=(0, 0, 0)) floor = bpy.context.object # Adiciona f\u00edsica de colis\u00e3o ao ch\u00e3o bpy.ops.object.modifier_add(type='COLLISION') # Configura\u00e7\u00f5es de cena e anima\u00e7\u00e3o bpy.context.scene.frame_start = 1 bpy.context.scene.frame_end = 250 # Executa a anima\u00e7\u00e3o (opcional, se voc\u00ea quiser simular direto) bpy.ops.ptcache.bake_all(bake=True) Explica\u00e7\u00e3o do C\u00f3digo: Limpeza da Cena : O c\u00f3digo inicial limpa todos os objetos da cena padr\u00e3o. Cria\u00e7\u00e3o e Configura\u00e7\u00e3o do Cubo : Adiciona um cubo na cena, o eleva do solo e adiciona um modificador de colis\u00e3o para que ele interaja com o tecido. Cria\u00e7\u00e3o e Configura\u00e7\u00e3o do Tecido : Adiciona um plano, o posiciona acima do cubo, subdivide para melhorar a qualidade da simula\u00e7\u00e3o e aplica o modificador Cloth para ativar a simula\u00e7\u00e3o de tecido. Cria\u00e7\u00e3o do Ch\u00e3o : Adiciona um plano abaixo do cubo para agir como ch\u00e3o e garantir que o tecido n\u00e3o caia indefinidamente. Configura\u00e7\u00e3o de Simula\u00e7\u00e3o : Define o intervalo de quadros para a anima\u00e7\u00e3o e realiza a simula\u00e7\u00e3o imediatamente (o bake ). Como Executar o Script: Abra o Blender . V\u00e1 para o Editor de Textos ( Scripting ) no topo. Crie um novo script e cole o c\u00f3digo acima. Clique em \"Run Script\" para executar e criar a cena automaticamente. Isso criar\u00e1 a simula\u00e7\u00e3o no Blender conforme descrito.","title":"Tecido"},{"location":"Exemplos/tecido/#tecido","text":"Para criar uma cena no Blender onde um tecido (um plano) cai sobre um cubo usando simula\u00e7\u00e3o de f\u00edsica de pano (cloth), siga estes passos:","title":"Tecido"},{"location":"Exemplos/tecido/#passo-1-configuracao-da-cena-basica","text":"Abra o Blender . Remova os objetos padr\u00e3o (geralmente um cubo). Selecione o cubo, pressione X e clique em \"Delete\". Adicione um novo cubo : Pressione Shift + A para abrir o menu de adi\u00e7\u00e3o. Selecione Mesh > Cube . Posicione o cubo em Z = 0 para ficar na superf\u00edcie da grade. Adicione um plano (Plane) para ser o tecido : Pressione Shift + A novamente e selecione Mesh > Plane . Posicione o plano acima do cubo (em Z = 2 por exemplo).","title":"Passo 1: Configura\u00e7\u00e3o da Cena B\u00e1sica"},{"location":"Exemplos/tecido/#passo-2-configuracao-da-fisica-do-cubo","text":"Selecione o cubo . No painel de propriedades, v\u00e1 para a aba de Physics (\u00edcone de c\u00edrculo com pontos dentro) e clique em Collision . Isso faz com que o cubo interaja com o tecido.","title":"Passo 2: Configura\u00e7\u00e3o da F\u00edsica do Cubo"},{"location":"Exemplos/tecido/#passo-3-configuracao-da-fisica-do-tecido","text":"Selecione o plano (que ser\u00e1 o tecido). No painel de propriedades, v\u00e1 para a aba de Physics e clique em Cloth . Aqui voc\u00ea pode ajustar as propriedades como massa, esticamento, flex\u00e3o, etc., para definir o comportamento do tecido.","title":"Passo 3: Configura\u00e7\u00e3o da F\u00edsica do Tecido"},{"location":"Exemplos/tecido/#passo-4-ajuste-da-resolucao-do-plano-opcional","text":"Subdivida o plano para que o tecido tenha mais pontos para a simula\u00e7\u00e3o: Selecione o plano. Pressione Tab para entrar no Modo de Edi\u00e7\u00e3o. Pressione Right Click e selecione Subdivide . No painel inferior esquerdo, aumente o n\u00famero de cortes para dar mais detalhe ao tecido. Pressione Tab novamente para sair do Modo de Edi\u00e7\u00e3o.","title":"Passo 4: Ajuste da Resolu\u00e7\u00e3o do Plano (Opcional)"},{"location":"Exemplos/tecido/#passo-5-simulacao","text":"Inicie a simula\u00e7\u00e3o : Pressione Space ou Shift + Space para iniciar a anima\u00e7\u00e3o. O plano (tecido) deve cair sobre o cubo e reagir como um tecido real.","title":"Passo 5: Simula\u00e7\u00e3o"},{"location":"Exemplos/tecido/#passo-6-ajustes-finais","text":"Ajuste o comportamento da simula\u00e7\u00e3o na aba Cloth se necess\u00e1rio. Adicione uma superf\u00edcie de ch\u00e3o (novo plano abaixo do cubo) e marque como Collision para que o tecido n\u00e3o caia indefinidamente.","title":"Passo 6: Ajustes Finais"},{"location":"Exemplos/tecido/#passo-7-renderizacao","text":"Configure a ilumina\u00e7\u00e3o e a c\u00e2mera para a cena. Renderize a anima\u00e7\u00e3o ou um frame espec\u00edfico da queda do tecido. Essa configura\u00e7\u00e3o simples deve permitir que o tecido caia e se deforme ao colidir com o cubo, criando uma cena realista de simula\u00e7\u00e3o f\u00edsica no Blender. Para criar essa cena no Blender usando um script Python, voc\u00ea pode seguir o roteiro abaixo. Esse script cria um cubo, adiciona um plano como tecido, configura a simula\u00e7\u00e3o de f\u00edsica e executa a anima\u00e7\u00e3o. import bpy # Limpa a cena padr\u00e3o bpy.ops.object.select_all(action='SELECT') bpy.ops.object.delete(use_global=False) # Adiciona um cubo bpy.ops.mesh.primitive_cube_add(size=2, location=(0, 0, 1)) # Pega o objeto rec\u00e9m-criado (o cubo) cube = bpy.context.object # Adiciona a f\u00edsica de colis\u00e3o ao cubo bpy.ops.object.modifier_add(type='COLLISION') # Adiciona um plano (plane) para ser o tecido bpy.ops.mesh.primitive_plane_add(size=4, location=(0, 0, 4)) plane = bpy.context.object # Subdivide o plano para aumentar a resolu\u00e7\u00e3o bpy.ops.object.mode_set(mode='EDIT') bpy.ops.mesh.subdivide(number_cuts=10) bpy.ops.object.mode_set(mode='OBJECT') # Adiciona a f\u00edsica de cloth ao plano bpy.ops.object.modifier_add(type='CLOTH') # Configura\u00e7\u00f5es adicionais para a simula\u00e7\u00e3o de tecido cloth_mod = plane.modifiers[\"Cloth\"] cloth_mod.settings.quality = 5 # Qualidade da simula\u00e7\u00e3o cloth_mod.settings.mass = 0.3 # Massa do tecido # Adiciona um ch\u00e3o abaixo do cubo para evitar queda infinita do tecido bpy.ops.mesh.primitive_plane_add(size=10, location=(0, 0, 0)) floor = bpy.context.object # Adiciona f\u00edsica de colis\u00e3o ao ch\u00e3o bpy.ops.object.modifier_add(type='COLLISION') # Configura\u00e7\u00f5es de cena e anima\u00e7\u00e3o bpy.context.scene.frame_start = 1 bpy.context.scene.frame_end = 250 # Executa a anima\u00e7\u00e3o (opcional, se voc\u00ea quiser simular direto) bpy.ops.ptcache.bake_all(bake=True)","title":"Passo 7: Renderiza\u00e7\u00e3o"},{"location":"Exemplos/tecido/#explicacao-do-codigo","text":"Limpeza da Cena : O c\u00f3digo inicial limpa todos os objetos da cena padr\u00e3o. Cria\u00e7\u00e3o e Configura\u00e7\u00e3o do Cubo : Adiciona um cubo na cena, o eleva do solo e adiciona um modificador de colis\u00e3o para que ele interaja com o tecido. Cria\u00e7\u00e3o e Configura\u00e7\u00e3o do Tecido : Adiciona um plano, o posiciona acima do cubo, subdivide para melhorar a qualidade da simula\u00e7\u00e3o e aplica o modificador Cloth para ativar a simula\u00e7\u00e3o de tecido. Cria\u00e7\u00e3o do Ch\u00e3o : Adiciona um plano abaixo do cubo para agir como ch\u00e3o e garantir que o tecido n\u00e3o caia indefinidamente. Configura\u00e7\u00e3o de Simula\u00e7\u00e3o : Define o intervalo de quadros para a anima\u00e7\u00e3o e realiza a simula\u00e7\u00e3o imediatamente (o bake ).","title":"Explica\u00e7\u00e3o do C\u00f3digo:"},{"location":"Exemplos/tecido/#como-executar-o-script","text":"Abra o Blender . V\u00e1 para o Editor de Textos ( Scripting ) no topo. Crie um novo script e cole o c\u00f3digo acima. Clique em \"Run Script\" para executar e criar a cena automaticamente. Isso criar\u00e1 a simula\u00e7\u00e3o no Blender conforme descrito.","title":"Como Executar o Script:"},{"location":"Exemplos/visualiza%C3%A7%C3%A3o/","text":"A visualiza\u00e7\u00e3o de informa\u00e7\u00f5es em 3D (tr\u00eas dimens\u00f5es) \u00e9 uma t\u00e9cnica poderosa que acrescenta profundidade e realismo \u00e0 representa\u00e7\u00e3o de dados, tornando-a particularmente \u00fatil em contextos onde a terceira dimens\u00e3o (profundidade) oferece insights adicionais. Vamos explorar os principais aspectos e aplica\u00e7\u00f5es da visualiza\u00e7\u00e3o 3D. Benef\u00edcios da Visualiza\u00e7\u00e3o 3D Profundidade de Informa\u00e7\u00e3o : A visualiza\u00e7\u00e3o 3D permite a representa\u00e7\u00e3o de dados complexos que t\u00eam m\u00faltiplas vari\u00e1veis interdependentes, adicionando uma camada extra de informa\u00e7\u00e3o que pode ser dif\u00edcil de captar em 2D. Interatividade : As visualiza\u00e7\u00f5es 3D muitas vezes permitem aos usu\u00e1rios explorar os dados de diferentes \u00e2ngulos, rodando, aproximando ou afastando o objeto, o que pode proporcionar uma compreens\u00e3o mais profunda do conjunto de dados. Realismo e Simula\u00e7\u00e3o : As visualiza\u00e7\u00f5es 3D s\u00e3o fundamentais para simula\u00e7\u00f5es realistas, como em jogos, engenharia, design de produto, e ambientes m\u00e9dicos. Elas podem replicar cen\u00e1rios do mundo real de maneira mais precisa. Engajamento e Imers\u00e3o : Visualiza\u00e7\u00f5es 3D tendem a ser mais imersivas e engajantes, capturando a aten\u00e7\u00e3o do p\u00fablico e facilitando uma melhor reten\u00e7\u00e3o de informa\u00e7\u00f5es. Aplica\u00e7\u00f5es da Visualiza\u00e7\u00e3o 3D Modelagem de Terrenos e Cartografia : Utilizada para representar a topografia de uma regi\u00e3o, como em mapas de eleva\u00e7\u00e3o, ou para criar modelos 3D de cidades e ambientes naturais. Ferramentas como GIS (Geographic Information Systems) frequentemente utilizam visualiza\u00e7\u00f5es 3D para mostrar a morfologia do terreno. Simula\u00e7\u00e3o e Engenharia : Nas engenharias (civil, mec\u00e2nica, aeroespacial), a visualiza\u00e7\u00e3o 3D \u00e9 usada para modelar e simular projetos antes da constru\u00e7\u00e3o ou fabrica\u00e7\u00e3o, permitindo an\u00e1lise de tens\u00f5es, fluxo de ar, etc. Programas como CAD (Computer-Aided Design) s\u00e3o fundamentais para o design e a visualiza\u00e7\u00e3o de modelos 3D. Ci\u00eancias M\u00e9dicas e Biol\u00f3gicas : Em biologia e medicina, as visualiza\u00e7\u00f5es 3D s\u00e3o usadas para modelar estruturas biol\u00f3gicas complexas, como prote\u00ednas, \u00f3rg\u00e3os ou sistemas inteiros. Tomografias e resson\u00e2ncias magn\u00e9ticas podem ser transformadas em modelos 3D para planejamento cir\u00fargico ou educa\u00e7\u00e3o m\u00e9dica. An\u00e1lises de Dados Complexos : Usada para representar dados multidimensionais, como em estat\u00edsticas avan\u00e7adas ou an\u00e1lise de big data, onde mais de duas vari\u00e1veis precisam ser exibidas simultaneamente. Exemplo: Gr\u00e1ficos de dispers\u00e3o 3D para mostrar correla\u00e7\u00f5es entre tr\u00eas vari\u00e1veis. Arquitetura e Design de Interiores : Modelagem de edif\u00edcios e interiores em 3D permite que arquitetos e clientes visualizem espa\u00e7os antes da constru\u00e7\u00e3o, ajustando design e layout com maior precis\u00e3o. Ferramentas como SketchUp ou Revit s\u00e3o amplamente usadas nesse campo. Realidade Virtual (VR) e Realidade Aumentada (AR) : Em VR e AR, as visualiza\u00e7\u00f5es 3D criam ambientes imersivos onde os usu\u00e1rios podem interagir com dados e objetos virtuais de forma realista. Isso \u00e9 \u00fatil tanto em entretenimento quanto em treinamento, educa\u00e7\u00e3o, e simula\u00e7\u00f5es profissionais. Ferramentas e Tecnologias para Visualiza\u00e7\u00e3o 3D Unity e Unreal Engine : Motores de jogo que tamb\u00e9m s\u00e3o usados para criar visualiza\u00e7\u00f5es 3D interativas para uma variedade de aplica\u00e7\u00f5es, incluindo simula\u00e7\u00f5es e treinamentos. Blender : Uma ferramenta open-source para modelagem, anima\u00e7\u00e3o e renderiza\u00e7\u00e3o 3D. Amplamente usada em anima\u00e7\u00e3o, design de produto, e visualiza\u00e7\u00e3o cient\u00edfica. Python (com bibliotecas como Matplotlib e Mayavi) : Ferramentas como MATLAB e bibliotecas de Python permitem a cria\u00e7\u00e3o de gr\u00e1ficos 3D para an\u00e1lises cient\u00edficas e de engenharia. Mayavi, em particular, \u00e9 uma biblioteca poderosa para visualiza\u00e7\u00e3o cient\u00edfica 3D em Python. Plotly e Three.js : Plotly \u00e9 uma ferramenta de visualiza\u00e7\u00e3o interativa que suporta gr\u00e1ficos 3D diretamente no navegador. Three.js \u00e9 uma biblioteca JavaScript que facilita a cria\u00e7\u00e3o de gr\u00e1ficos 3D complexos para web, permitindo a constru\u00e7\u00e3o de visualiza\u00e7\u00f5es interativas diretamente no navegador. Autodesk Maya e 3ds Max : Ferramentas profissionais para modelagem e anima\u00e7\u00e3o 3D, amplamente usadas em filmes, jogos, e design de produtos. Desafios e Considera\u00e7\u00f5es Complexidade de Desenvolvimento : A cria\u00e7\u00e3o de visualiza\u00e7\u00f5es 3D pode ser mais complexa e demorada do que 2D, exigindo habilidades t\u00e9cnicas avan\u00e7adas e maior poder computacional. Performance e Otimiza\u00e7\u00e3o : Visualiza\u00e7\u00f5es 3D, especialmente as interativas, podem ser intensivas em termos de processamento, exigindo uma otimiza\u00e7\u00e3o cuidadosa para garantir que funcionem suavemente, especialmente em dispositivos menos poderosos. Usabilidade e Compreens\u00e3o : Embora visualmente atraentes, visualiza\u00e7\u00f5es 3D podem ser mais dif\u00edceis de interpretar para usu\u00e1rios n\u00e3o treinados. Garantir que a visualiza\u00e7\u00e3o seja intuitiva e que n\u00e3o sobrecarregue o usu\u00e1rio com informa\u00e7\u00f5es desnecess\u00e1rias \u00e9 essencial. Acessibilidade : As visualiza\u00e7\u00f5es 3D podem n\u00e3o ser t\u00e3o acess\u00edveis quanto as 2D para todos os p\u00fablicos, especialmente para aqueles com defici\u00eancias visuais ou que usam dispositivos com capacidades limitadas. A visualiza\u00e7\u00e3o 3D \u00e9 uma ferramenta poderosa e vers\u00e1til, com aplica\u00e7\u00f5es em diversas \u00e1reas do conhecimento e da ind\u00fastria. Quando bem implementada, pode transformar dados complexos em insights valiosos e experi\u00eancias envolventes.","title":"Visualiza\u00e7\u00e3o"},{"location":"Exemplos/visualiza%C3%A7%C3%A3o/#beneficios-da-visualizacao-3d","text":"Profundidade de Informa\u00e7\u00e3o : A visualiza\u00e7\u00e3o 3D permite a representa\u00e7\u00e3o de dados complexos que t\u00eam m\u00faltiplas vari\u00e1veis interdependentes, adicionando uma camada extra de informa\u00e7\u00e3o que pode ser dif\u00edcil de captar em 2D. Interatividade : As visualiza\u00e7\u00f5es 3D muitas vezes permitem aos usu\u00e1rios explorar os dados de diferentes \u00e2ngulos, rodando, aproximando ou afastando o objeto, o que pode proporcionar uma compreens\u00e3o mais profunda do conjunto de dados. Realismo e Simula\u00e7\u00e3o : As visualiza\u00e7\u00f5es 3D s\u00e3o fundamentais para simula\u00e7\u00f5es realistas, como em jogos, engenharia, design de produto, e ambientes m\u00e9dicos. Elas podem replicar cen\u00e1rios do mundo real de maneira mais precisa. Engajamento e Imers\u00e3o : Visualiza\u00e7\u00f5es 3D tendem a ser mais imersivas e engajantes, capturando a aten\u00e7\u00e3o do p\u00fablico e facilitando uma melhor reten\u00e7\u00e3o de informa\u00e7\u00f5es.","title":"Benef\u00edcios da Visualiza\u00e7\u00e3o 3D"},{"location":"Exemplos/visualiza%C3%A7%C3%A3o/#aplicacoes-da-visualizacao-3d","text":"Modelagem de Terrenos e Cartografia : Utilizada para representar a topografia de uma regi\u00e3o, como em mapas de eleva\u00e7\u00e3o, ou para criar modelos 3D de cidades e ambientes naturais. Ferramentas como GIS (Geographic Information Systems) frequentemente utilizam visualiza\u00e7\u00f5es 3D para mostrar a morfologia do terreno. Simula\u00e7\u00e3o e Engenharia : Nas engenharias (civil, mec\u00e2nica, aeroespacial), a visualiza\u00e7\u00e3o 3D \u00e9 usada para modelar e simular projetos antes da constru\u00e7\u00e3o ou fabrica\u00e7\u00e3o, permitindo an\u00e1lise de tens\u00f5es, fluxo de ar, etc. Programas como CAD (Computer-Aided Design) s\u00e3o fundamentais para o design e a visualiza\u00e7\u00e3o de modelos 3D. Ci\u00eancias M\u00e9dicas e Biol\u00f3gicas : Em biologia e medicina, as visualiza\u00e7\u00f5es 3D s\u00e3o usadas para modelar estruturas biol\u00f3gicas complexas, como prote\u00ednas, \u00f3rg\u00e3os ou sistemas inteiros. Tomografias e resson\u00e2ncias magn\u00e9ticas podem ser transformadas em modelos 3D para planejamento cir\u00fargico ou educa\u00e7\u00e3o m\u00e9dica. An\u00e1lises de Dados Complexos : Usada para representar dados multidimensionais, como em estat\u00edsticas avan\u00e7adas ou an\u00e1lise de big data, onde mais de duas vari\u00e1veis precisam ser exibidas simultaneamente. Exemplo: Gr\u00e1ficos de dispers\u00e3o 3D para mostrar correla\u00e7\u00f5es entre tr\u00eas vari\u00e1veis. Arquitetura e Design de Interiores : Modelagem de edif\u00edcios e interiores em 3D permite que arquitetos e clientes visualizem espa\u00e7os antes da constru\u00e7\u00e3o, ajustando design e layout com maior precis\u00e3o. Ferramentas como SketchUp ou Revit s\u00e3o amplamente usadas nesse campo. Realidade Virtual (VR) e Realidade Aumentada (AR) : Em VR e AR, as visualiza\u00e7\u00f5es 3D criam ambientes imersivos onde os usu\u00e1rios podem interagir com dados e objetos virtuais de forma realista. Isso \u00e9 \u00fatil tanto em entretenimento quanto em treinamento, educa\u00e7\u00e3o, e simula\u00e7\u00f5es profissionais.","title":"Aplica\u00e7\u00f5es da Visualiza\u00e7\u00e3o 3D"},{"location":"Exemplos/visualiza%C3%A7%C3%A3o/#ferramentas-e-tecnologias-para-visualizacao-3d","text":"Unity e Unreal Engine : Motores de jogo que tamb\u00e9m s\u00e3o usados para criar visualiza\u00e7\u00f5es 3D interativas para uma variedade de aplica\u00e7\u00f5es, incluindo simula\u00e7\u00f5es e treinamentos. Blender : Uma ferramenta open-source para modelagem, anima\u00e7\u00e3o e renderiza\u00e7\u00e3o 3D. Amplamente usada em anima\u00e7\u00e3o, design de produto, e visualiza\u00e7\u00e3o cient\u00edfica. Python (com bibliotecas como Matplotlib e Mayavi) : Ferramentas como MATLAB e bibliotecas de Python permitem a cria\u00e7\u00e3o de gr\u00e1ficos 3D para an\u00e1lises cient\u00edficas e de engenharia. Mayavi, em particular, \u00e9 uma biblioteca poderosa para visualiza\u00e7\u00e3o cient\u00edfica 3D em Python. Plotly e Three.js : Plotly \u00e9 uma ferramenta de visualiza\u00e7\u00e3o interativa que suporta gr\u00e1ficos 3D diretamente no navegador. Three.js \u00e9 uma biblioteca JavaScript que facilita a cria\u00e7\u00e3o de gr\u00e1ficos 3D complexos para web, permitindo a constru\u00e7\u00e3o de visualiza\u00e7\u00f5es interativas diretamente no navegador. Autodesk Maya e 3ds Max : Ferramentas profissionais para modelagem e anima\u00e7\u00e3o 3D, amplamente usadas em filmes, jogos, e design de produtos.","title":"Ferramentas e Tecnologias para Visualiza\u00e7\u00e3o 3D"},{"location":"Exemplos/visualiza%C3%A7%C3%A3o/#desafios-e-consideracoes","text":"Complexidade de Desenvolvimento : A cria\u00e7\u00e3o de visualiza\u00e7\u00f5es 3D pode ser mais complexa e demorada do que 2D, exigindo habilidades t\u00e9cnicas avan\u00e7adas e maior poder computacional. Performance e Otimiza\u00e7\u00e3o : Visualiza\u00e7\u00f5es 3D, especialmente as interativas, podem ser intensivas em termos de processamento, exigindo uma otimiza\u00e7\u00e3o cuidadosa para garantir que funcionem suavemente, especialmente em dispositivos menos poderosos. Usabilidade e Compreens\u00e3o : Embora visualmente atraentes, visualiza\u00e7\u00f5es 3D podem ser mais dif\u00edceis de interpretar para usu\u00e1rios n\u00e3o treinados. Garantir que a visualiza\u00e7\u00e3o seja intuitiva e que n\u00e3o sobrecarregue o usu\u00e1rio com informa\u00e7\u00f5es desnecess\u00e1rias \u00e9 essencial. Acessibilidade : As visualiza\u00e7\u00f5es 3D podem n\u00e3o ser t\u00e3o acess\u00edveis quanto as 2D para todos os p\u00fablicos, especialmente para aqueles com defici\u00eancias visuais ou que usam dispositivos com capacidades limitadas. A visualiza\u00e7\u00e3o 3D \u00e9 uma ferramenta poderosa e vers\u00e1til, com aplica\u00e7\u00f5es em diversas \u00e1reas do conhecimento e da ind\u00fastria. Quando bem implementada, pode transformar dados complexos em insights valiosos e experi\u00eancias envolventes.","title":"Desafios e Considera\u00e7\u00f5es"}]}